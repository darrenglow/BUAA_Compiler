# 编译实验

## 文法解读

### 问题

![image-20230912155519043](C:\Users\66418\AppData\Roaming\Typora\typora-user-images\image-20230912155519043.png)

这里怎么通过文法来判断是不是有return Exp呢？

### 实验

![image-20230912150221098](C:\Users\66418\AppData\Roaming\Typora\typora-user-images\image-20230912150221098.png)

完成A级：

```c
int a = 1, b = 0, c = 1;
if (a && b)
{
    printf("&& branch")
}
else if (a || b)
{
    printf("|| branch\n")
}
if (a && b || c)
{
    printf("&& || branch");
}
```

完成B级：

**注意：常量数组不能当做参数传入函数**

```c
//常量定义

//函数形参

//左值表达式

//函数实参
```

完成C级：

```c
//常量定义。
//变量定义。VarDecl → BType VarDef { ',' VarDef } ';' 
//函数定义。 FuncDef → FuncType Ident '(' [FuncFParams] ')' Block
/*
int/void
() (...)
{} {...}
*/

//语句stmt的情况
//1. LVal '=' Exp ';'
//左值表达式 LVal → Ident {'[' Exp ']'} 
//exp->addexp(有无+-) -> mulexp(有无*/%) -> unaryexp(primaryexp, 函数调用, +-unaryexp) -> primaryexp(有括号的exp, 左值， 数字)
//b = (a / 1) * (a + 2) * (a % a) + a - 1 + f0() - f1(a) * f2(a, a);

//2. [Exp] ';'

//3. Block

//4. 'if' '(' Cond ')' Stmt [ 'else' Stmt ]
//Cond->LOrExp
//LOrExp → LAndExp
//LAndExp → EqExp
//EqExp → RelExp | EqExp ('==' | '!=') RelExp
//RelExp → AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp

//5.'for' '(' [ForStmt] ';' [Cond] ';' [ForStmt] ')' Stmt 
//6.continue, break
//7.getint
```

## 词法分析

| 单词名称         | 类别码     | 单词名称 | 类别码   | 单词名称 | 类别码 | 单词名称 | 类别码  |
| ---------------- | ---------- | -------- | -------- | -------- | ------ | -------- | ------- |
| **Ident**        | IDENFR     | !        | NOT      | *        | MULT   | =        | ASSIGN  |
| **IntConst**     | INTCON     | &&       | AND      | /        | DIV    | ;        | SEMICN  |
| **FormatString** | STRCON     | \|\|     | OR       | %        | MOD    | ,        | COMMA   |
| main             | MAINTK     | while    | WHILETK  | <        | LSS    | (        | LPARENT |
| const            | CONSTTK    | getint   | GETINTTK | <=       | LEQ    | )        | RPARENT |
| int              | INTTK      | printf   | PRINTFTK | >        | GRE    | [        | LBRACK  |
| break            | BREAKTK    | return   | RETURNTK | >=       | GEQ    | ]        | RBRACK  |
| continue         | CONTINUETK | +        | PLUS     | ==       | EQL    | {        | LBRACE  |
| if               | IFTK       | -        | MINU     | !=       | NEQ    | }        | RBRACE  |
| else             | ELSETK     | void     | VOIDTK   |          |        |          |         |

### 编码前设计

```
Lexer/Lexer.h：定义Lexer类
Lexer/Lexer.cpp：类的函数具体实现
Lexer/Token.h: 定义Token类
```

`Lexer.cpp`： 

- 功能：读取文件，提取单词，返回单词串

- 元素：
  - `std::string token`：正在读取的token
  - `char c`：读取的字符
  - `int curLine`：当前行
  - `std::vector<Token*> tokens` ：所有的token

流程：

1. 读取文件
2. 每次先读取一个字符，再对这个字符进行判断，看是否需要进一步的处理。
3. 如果该次获取到了有效的字符串，根据这个字符串去查找他所属的`tokentype`，并将其加入到`tokens`中。
4. 最后输出时，将`tokens`输出到文件即可。

### 编码中的细节

**语言上的细节**：

- cpp中重载运算符需要使用友元的形式。

- `static`必须在类的外部定义

- `ifstream`

  ```c++
  class Lexer{
  private:
      std::vector<Token> tokens;
      std::ifstream& input;
  public:
      Lexer(std::ifstream& input_) : input(input_) {}
  };
  ```

  这里的input如果不是&就会报错，某种奇怪的原因，貌似是啥拷贝构造之类的。使用引用的方式就行。

- `const`放在函数后表示该函数不改变成员变量的值。

- `map.find()`函数

```c++
auto iter = str2type.find(str);
if (iter == str2type.end())	//找不到
{
    iter->second;	//得到str键对应的值
}
else {	//找得到
    
}
```

- `string.push_back`比`string+`快，因为`string+`会将后面的字符先构造成string对象。

**实现上的细节**

- 使用enum枚举Token，为了方便打印，将enum枚举的位置和tokenName的位置进行对应。
- 将`input`和`output`放哪的问题纠结了好一会，最后选择都在`main.cpp`中定义，在`lexer.cpp`中使用`extern`的形式使用，感觉这样很方便。
- 需要实现的`str2type`和`type2str`。后者一开始没有考虑到，因为要涉及到打印`type`。
- 对于换行的处理，每次读取一个字符，如果读到了换行符，就会将`curLine+1`
- **每次先读取一个字符**。意味着在每次`nextToken`开始的时候，`ch`就是已经在上一次循环最后读取到的。**很重要，忽略了的话就死循环了...**

### 总结

一开始感觉无从下手，一方面是第一次接触c++的项目，一方面是对于词法分析的要求还理解得不是很透彻。

我首先看了看c++项目的一般流程，学习了怎么使用`cmakelist`，以及在使用c++的类的时候的注意事项，还有很多语法上的细节都是在后面边做边搜的，感觉收获了不少了。

之后我在做之前先参考学习了课程组提供的pl0编译器的代码，以及其他优秀的编译器的设计，在广泛学习并构思后，我才开始了我的编码，感觉就会挺顺畅的。
