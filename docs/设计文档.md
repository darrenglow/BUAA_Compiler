# 编译实验

## 文法解读

### 问题

![image-20230912155519043](C:\Users\66418\AppData\Roaming\Typora\typora-user-images\image-20230912155519043.png)

这里怎么通过文法来判断是不是有return Exp呢？

### 实验

![image-20230912150221098](C:\Users\66418\AppData\Roaming\Typora\typora-user-images\image-20230912150221098.png)

完成A级：

```c
int a = 1, b = 0, c = 1;
if (a && b)
{
    printf("&& branch")
}
else if (a || b)
{
    printf("|| branch\n")
}
if (a && b || c)
{
    printf("&& || branch");
}
```

完成B级：

**注意：常量数组不能当做参数传入函数**

```c
//常量定义

//函数形参

//左值表达式

//函数实参
```

完成C级：

```c
//常量定义。
//变量定义。VarDecl → BType VarDef { ',' VarDef } ';' 
//函数定义。 FuncDef → FuncType Ident '(' [FuncFParams] ')' Block
/*
int/void
() (...)
{} {...}
*/

//语句stmt的情况
//1. LVal '=' Exp ';'
//左值表达式 LVal → Ident {'[' Exp ']'} 
//exp->addexp(有无+-) -> mulexp(有无*/%) -> unaryexp(primaryexp, 函数调用, +-unaryexp) -> primaryexp(有括号的exp, 左值， 数字)
//b = (a / 1) * (a + 2) * (a % a) + a - 1 + f0() - f1(a) * f2(a, a);

//2. [Exp] ';'

//3. Block

//4. 'if' '(' Cond ')' Stmt [ 'else' Stmt ]
//Cond->LOrExp
//LOrExp → LAndExp
//LAndExp → EqExp
//EqExp → RelExp | EqExp ('==' | '!=') RelExp
//RelExp → AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp

//5.'for' '(' [ForStmt] ';' [Cond] ';' [ForStmt] ')' Stmt 
//6.continue, break
//7.getint
```

## 词法分析

| 单词名称         | 类别码     | 单词名称 | 类别码   | 单词名称 | 类别码 | 单词名称 | 类别码  |
| ---------------- | ---------- | -------- | -------- | -------- | ------ | -------- | ------- |
| **Ident**        | IDENFR     | !        | NOT      | *        | MULT   | =        | ASSIGN  |
| **IntConst**     | INTCON     | &&       | AND      | /        | DIV    | ;        | SEMICN  |
| **FormatString** | STRCON     | \|\|     | OR       | %        | MOD    | ,        | COMMA   |
| main             | MAINTK     | while    | WHILETK  | <        | LSS    | (        | LPARENT |
| const            | CONSTTK    | getint   | GETINTTK | <=       | LEQ    | )        | RPARENT |
| int              | INTTK      | printf   | PRINTFTK | >        | GRE    | [        | LBRACK  |
| break            | BREAKTK    | return   | RETURNTK | >=       | GEQ    | ]        | RBRACK  |
| continue         | CONTINUETK | +        | PLUS     | ==       | EQL    | {        | LBRACE  |
| if               | IFTK       | -        | MINU     | !=       | NEQ    | }        | RBRACE  |
| else             | ELSETK     | void     | VOIDTK   |          |        |          |         |

### 编码前设计

```
Lexer/Lexer.h：定义Lexer类
Lexer/Lexer.cpp：类的函数具体实现
Lexer/Token.h: 定义Token类
```

`Lexer.cpp`： 

- 功能：读取文件，提取单词，返回单词串

- 元素：
  - `std::string token`：正在读取的token
  - `char c`：读取的字符
  - `int curLine`：当前行
  - `std::vector<Token*> tokens` ：所有的token

流程：

1. 读取文件
2. 每次先读取一个字符，再对这个字符进行判断，看是否需要进一步的处理。
3. 如果该次获取到了有效的字符串，根据这个字符串去查找他所属的`tokentype`，并将其加入到`tokens`中。
4. 最后输出时，将`tokens`输出到文件即可。

### 编码中的细节

**语言上的细节**：

- cpp中重载运算符需要使用友元的形式。

- `static`必须在类的外部定义

- `ifstream`

  ```c++
  class Lexer{
  private:
      std::vector<Token> tokens;
      std::ifstream& input;
  public:
      Lexer(std::ifstream& input_) : input(input_) {}
  };
  ```

  这里的input如果不是&就会报错，某种奇怪的原因，貌似是啥拷贝构造之类的。使用引用的方式就行。

- `const`放在函数后表示该函数不改变成员变量的值。

- `map.find()`函数

```c++
auto iter = str2type.find(str);
if (iter == str2type.end())	//找不到
{
    iter->second;	//得到str键对应的值
}
else {	//找得到
    
}
```

- `string.push_back`比`string+`快，因为`string+`会将后面的字符先构造成string对象。

**实现上的细节**

- 使用enum枚举Token，为了方便打印，将enum枚举的位置和tokenName的位置进行对应。
- 将`input`和`output`放哪的问题纠结了好一会，最后选择都在`main.cpp`中定义，在`lexer.cpp`中使用`extern`的形式使用，感觉这样很方便。
- 需要实现的`str2type`和`type2str`。后者一开始没有考虑到，因为要涉及到打印`type`。
- 对于换行的处理，每次读取一个字符，如果读到了换行符，就会将`curLine+1`
- **每次先读取一个字符**。意味着在每次`nextToken`开始的时候，`ch`就是已经在上一次循环最后读取到的。**很重要，忽略了的话就死循环了...**

### 总结

一开始感觉无从下手，一方面是第一次接触c++的项目，一方面是对于词法分析的要求还理解得不是很透彻。

我首先看了看c++项目的一般流程，学习了怎么使用`cmakelist`，以及在使用c++的类的时候的注意事项，还有很多语法上的细节都是在后面边做边搜的，感觉收获了不少了。

之后我在做之前先参考学习了课程组提供的pl0编译器的代码，以及其他优秀的编译器的设计，在广泛学习并构思后，我才开始了我的编码，感觉就会挺顺畅的。

## 语法分析

### 编码前设计

因为涉及到了对`tokenList`的操作，所以我在这里将之前设计的简单重构了一下，将`std::vector<Token*>`封装成了一个类`TokenList`，方便在`Parser`阶段调用类的方法进行操作

封装了`Parser`类，将`Lexer`解析得到的`tokenList`对象传入`Parser`中，执行`parse`方法开始递归下降解析。



1. 文法中存在左递归的文法，需要改写

```
MulExp -> UnaryExp | MulExp ('*' | '/' | '%') UnaryExp
MulExp -> UnaryExp { ('*' | '/' | '%') UnaryExp }

AddExp -> MulExp | AddExp ('+' | '−') MulExp
AddExp -> MulExp { ('+' | '−') MulExp }

RelExp -> AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp
RelExp -> AddExp { ('<' | '>' | '<=' | '>=') AddExp }

EqExp -> RelExp | EqExp ('==' | '!=') RelExp
EqExp -> RelExp { ('==' | '!=') RelExp }

LAndExp -> EqExp | LAndExp '&&' EqExp
LAndExp -> EqExp { '&&' EqExp }

LOrExp -> LAndExp | LOrExp '||' LAndExp
LOrExp -> LAndExp { '||' LAndExp }


```

2. Stmt的语法规则太复杂，可以新增非终结符，让结构更加清晰。

```
<AssignStmt> -> LVal '=' Exp
<ExpStmt> -> Exp
<BlockStmt> -> Block
<IfStmt> -> 'if' '(' Cond ')' Stmt [ 'else' Stmt ]
<ForStmt> -> 'for' '(' [AssignStmt] ';' [Cond] ';' [ForStmt] ')' Stmt
(原有的ForStmt改名为了AssignStmt)
<BreakStmt> -> 'break'
<ContinueStmt> -> 'continue'
<ReturnStmt> -> 'return' [Exp]
<InputStmt> -> LVal '=' 'getint' '(' ')'
<OutputStmt> -> 'printf''('FormatString{','Exp}')'
```

3. `MainFuncDef`和`FuncDef`类似，直接当做`FuncDef`来处理。
4. 考虑到将语法分析与后面的部分解耦，计划实现语法树。每个节点都是`Node`，因为是树，所以有`Node* parent`和`std::vector<Node*> children`的成员。
5. 因为`Node`可能是终结符和非终结符，所以具有两种成员，`Token* term`和`NoTerminal noTerm`

### 编码中的细节

- 要构建语法树
- `constdecl`和`vardecl`可以合并，用一个`isConst`来区分，同时`constdef`和`vardef`也可以合并。

- （不确定）`UnaryExp`中的`UnaryOp`我不知道包不包括`!`，同时如果想要判断是否是`PrimaryExp`，不知道怎么判断int，只好把这个写在`else`里面。

**----------------在与助教沟通后，对整体的语法树结构、以及其他设计进行了重构修改------------------**

- **不再使用`Node`来构建语法树，对于每种非终结符都设计单独的类，方便后续的处理，在`AST.h`中**
- 只将有具体含义的、重要的节点插入语法树中，而不是将所有的token都加入。
- 在输出结果时，对每种非终结符都重写其输出函数，在`AST.cpp`中实现。

- `Stmt`中的`LVal '=' Exp ';' `和`[Exp] ';'`和`LVal '=' 'getint''('')'';'`的判断。。。

```
 Exp → AddExp -> MulExp -> UnaryExp ->  '(' | LVal | Number | Ident '(' | '+' | '-' | '!'
 LVal -> Ident
 虽然Ident是重复的，但是可以使用Ident '('来特殊判断Exp
 
 剩下两个的话，可以先parseLVal()，再看后面的一个是不是'getint'。
```

- 像`LOrExp -> LAndExp { '||' LAndExp }`，一开始把`||`没有插入语法树，但是想想，还是得插入，并且得判断是不是`||`

- 为了控制输出，使用#define来控制

### 编码中错误

- 有些地方的换行符漏加
- 有处的指针未取值
- `UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')' `输出忘了`Ident`后面的部分
- 由于改写了文法取消了左递归，但是实际上还是需要写出来。

![image-20230924162510224](C:\Users\66418\AppData\Roaming\Typora\typora-user-images\image-20230924162510224.png)

- 将`AddExp->MulExp {( '+' | '-') MulExp}`中的+-当做了unaryop，但其实只是简单的Token.
- stmt的[exp]可以以`!`开头吗？我现在没用

### 总结

这部分花了我可能一周的时间，从学习知识到设计到编码，一开始不明白怎么构建语法树，只使用一个`Node`的方式来构建，并且把每个token都存入语法树中，工作量非常的大。好在咨询了助教，及时地对代码进行了重构，采用每种非终结符对应一个类的形式，构建语法树时也简便不少，提前设计好真的太重要了！！！不过现在的设计感觉还是有些繁琐，每个非终结符都对应一个`parse`和一个重载输出`<<`，每个文件都几百行代码，个人感觉不太优雅，可能可以把其中的某几部分合起来，但是没有再细细设计，直接简单粗暴地编写程序了。

不过由于对后续的任务不是很清楚，不知道现在这种语法树的构建是否有问题，可能还需要进行重构。

## 错误处理

### 编码前设计

为了处理错误，定义Error类，包括错误的类型和错误所在的行数

为了记录错误，定义ErrorTable类，Error对象的集合。

纵览所有需要处理的错误类型，一一进行分析：

- 非法符号ILLEGAL_FORMATSTRING：在词法分析时对FormatString进行判断。**词法分析**
- 名字重定义DUPLICATE_IDENT: 函数名、变量名在当前作用域重复定义，需要建立符号表进行判断。**符号表**
- 未定义UNDEFINED_IDENT：根据符号表，判断是否未定义。**符号表**
- 函数参数个数不匹配MISMATCH_PARAM_NUM：根据符号表，可以判断定义的函数参数个数，和调用的参数个数。**符号表**
- 函数类型不匹配MISMATCH_PARAM_TYPE：同上判断**符号表**
- void函数有不匹配的return。VOID_MISMATCH_RETURN。**符号表**
- 有返回值的函数缺少return。LACK_RETURN**符号表**
- 不能改变常量的值CHANGE_CONST**符号表**
- 缺少分号：LACK_SEMICN：语法分析阶段得到。**语法分析**
- 缺少右小括号LACK_RIGHT_PARENT：语法分析阶段得到。**语法分析**
- 缺少右中括号LACK_RIGHT_BRACK：语法分析阶段得到。**语法分析**
- print中格式字符与表达式个数不匹配PRINTF_MISMATCH_NUM。**符号表**
- 非循环块中使用break, continue BREAK_CONTINUE_OUT_LOOP。**符号表**

词法分析与语法分析可对部分错误进行判断，在遍历语法树的过程中建立符号表，并进行额外的错误处理。当检测到错误时，将错误添加入错误表中。结束时按照要求对错误表进行输出。

- 符号表：

  建立树形的符号表，方便管理

  对于符号表，在进入`CompUnit`, `Block`, `FuncDecl`时新建符号表，并以当前符号表作为父节点。

  插入符号：检测当前级符号表中是否有同名变量，有则报错。
  
  查找符号：从当前级符号表向上查找到最近的。

### 编码时细节

- 对于`ErrorTable`，设计为单例模式，这个类在词法、语法、后续的代码生成中均有出现。

- 由于之前设计了`popExpect`的函数，所以在处理`i, j, k`与语法相关的错误时，可以都放在这个函数中处理。

- **错误g**：在涉及到`return`时，由于只需要考虑最后一行是否有`return`，大大简化了操作，就获取到`block`的最后一个item然后判断即可。错误行号是`}`的位置，而我并没有记录这个值，在AST中重新添加。

- 对于`visitBlock`，如果是函数的{}，那由于需要考虑形参也作用在这个里面，就不重新建符号表了。而如果是stmt中的`block`，那就需要重新建符号表了。

- **错误f**：考虑函数的返回值是否是空，以及最后一行的`returnStmt`中是否有`exp`，如果同时满足，则报错。

- **错误d**：实参和形参的类型匹配，计算实参的维度时，由于实参是`exp`，

- 当`funcFParam`在函数体中出现时，符号表中是`FuncFParamSymbol`，但是我为了判断这个变量是否是常量，我并不知道这个符号是`FuncFParamSymbol`还是`ValueSymbol`，因此如果想判断是否是常量就很麻烦。因此，我采用了多态的动态绑定，将`isConst()`方法写在父类`Symbol`上，在`ValueSymbol`和`FuncFParamSymbol`类里分别实现，这样，即使只从符号表中获取到指向`Symbol`的指针，也可以通过`p->isConst()`来得到是否是变量。

- 同上，在`PrimaryExp::getDim()`中，如果用到了函数参数的维度，那么也需要从符号表中拿到，会遇到和上一点一样的问题。

  ```c++
  auto valueSymbol = dynamic_cast<ValueSymbol*>(Visitor::curTable->getSymbol(name, true));
  int realDim = (int)(valueSymbol->dims.size()) - formDim;   // 实际传入的维度
  ```

  应改成：

  ```c++
  auto symbol = Visitor::curTable->getSymbol(name, true);
  int realDim = (int)(symbol->getDim()) - formDim;   // 实际传入的维度
  ```

  在`Symbol.h`中对将`getDim()`写成虚函数，然后实现动态绑定

### 编码时错误

- 发现了词法分析中的错误，设置当前token的行数时，不应该一直用curLine，因为有些会读到换行符导致curLine变化，应该在一开始处理时就将`curLine`先记录下来。

- 发现了语法分析中的错误。`a;`这句话会判断为`assignStmt`。

  在`parseStmt()`时

  ```
  LVal '=' Exp ';'
  [Exp] ';'
  LVal '=' 'getint''('')'';'
  ```

  这几个的FIRST都有可能是`LVAL`，我一开始只考虑了1,3，第二种情况没有考虑。

  首先`parseLVal`，将难处理的`LVal`读取，在这时只有可能是`LVal`，其他的情况在之前的if中已经得到判断。之后根据后一个符号是否是`=`，如果是就再判断1,3，如果不是，就只会是`expStmt`。

- 当`visitFuncDef`时，因为我想要把`FuncFParamSymbol`存在`FuncSymbol`中，所以是在`visitFuncFParam()`之后才新建了符号表，导致`FuncFParamSymbol`插入到了错误的符号表中。

- `FuncDef`的成员`FuncFParams`可能为空，获取`FuncDef`的参数数量时报错

- 当遇到`int f({`的情况是，由于我的语法分析中，在`parseFParam()`时是根据是否是右括号判断的，这样的话就会有问题，改成了根据是否是`INT`来判断

- 在`visitFuncDef()`中，我在得到最后一个`blockItem`后，没有考虑会有`blockItem->decl`的情况，只考虑了`stmt`，导致如果出现

  ```c++
  int f(){
      int a;
  }
  ```

  就会出现错误。

### 总结

- **符号表的最终设计与设计前没变，即采用树形的结构创建**

- **符号项的设计**：符号基类、函数形参符号、函数符号、值符号。下面列出主要的属性。

  - 符号基类

    ```c++
    class Symbol{
    public:
        std::string name;
        BasicType basicType;    // 默认都是int
        virtual bool isConst() const = 0;
        virtual int getDim() const = 0;
    };
    ```

  - 函数形参符号

    ```cpp
    class FuncFParamSymbol : public Symbol  {
    public:
        std::vector<int> dims;
        ValueType valueType;
        
        bool isConst() const {
            return false;
        }
        int getDim() const {
            return dims.size();
        }
    };
    ```

  - 函数符号

    ```c++
    class FuncSymbol : public Symbol {
    public:
        int num;
        std::vector<FuncFParamSymbol*> funcFParamSymbols;
        
        bool isConst() const {
            return false;
        }
        int getDim() const {
            return -100;
        }
    };
    ```

  - 值符号

    ```cpp
    class ValueSymbol : public Symbol {
    public:
        ValueType valueType;
        std::vector<int> dims;   //具体维度
        std::vector<int> initValues; //展开后的一维值
        int initValue;
        bool isConstValue;
        
        bool isConst() const {
            return isConstValue;
        }
        int getDim() const {
            return dims.size();
        }
    };
    ```

- 这一部分比较困难的一部分是维度的确定和维度的对应。确定维度时，由于是`Exp`的语法成分，而真正包括了维度信息的是在`LVal`中，所以需要不断地向里面挖，我采用的就是这种比较暴力的方式。维度的对应涉及到实参的维度和形参的维度，对于实参的维度需要格外注意，比如

  ```c++
  int a[10];
  f(a);	//此时传入的就是一维的
  int b[10][20];
  f(b);	//此时传入的就是二维的
  f(b[0]);	//此时的b就是一维的
  ```

  **实参真正传入的维度=符号表中的维度 - 实参看起来的维度**

## 中间代码生成

### 编码前学习

一开始想使用llvm->mips，但是一位大佬劝退，感觉难度会很大，采用四元式。

`(op, arg1, arg2, result)`

```
x = y + z表示为：
+, y, z, t1 -> t1=y+z
=, t1, , x -> x=t1
```

- 主函数
- 赋值语句

```
// a = num[0]
[], num, 0, t1
=, t1, , a
```

二维数组需要展成一维

- 条件语句

```
// if (x > y) then z = x + y 
// else z = x - y
>, x, y, t1
jnz t1 L
jmp M
L
+, x, y, t2
=, t2, , z
jmp N
M
-, x, y, t3
=, t3, , z
N
```

- 循环语句

```
// while (x < y) do x = x + 1
L
<, x, y, t1
beq, t1, 0, M
+, x, 1, t2
=, t2, , x
jmp L
M
```

```
// for (i = a; i < b; i = i + 1 ) {
// 		x = x + 1;
// }

=, a, , i

L
<, i, b, t1
beq, t1, 0, M
...	//x = x + 1;
+, i, 1, t2
=, t2, , i
jmp L

M
```

- 函数调用

```
// f(x, y)
=, x, , t1
param, t1, , 	//t1的地址压入栈
=, y, , t2
param, t2, , 	//t2的地址压入栈
call, f, , 		
```

- 读入和输出

```
// b=getint()
getint, , ,b

// printf("%d hello", x);
print_int, x, , 
print_string, hello, , 
```

**Mips复习**

```
ADD rd, rs, rt
SUB rd, rs, rt
MUL rd, rs, rt
DIV rs, rt	//商存入LO，余数存入HI
SLT	rd, rs, rt	

//存取指令
LW rt, offset(base)	 // LW $t1, 4($t2)
sw rt, offset(base)	 // SW $t1, 4($t2)

//分支指令
BEQ rs, rt, offset	// if(rs==rt) PC=PC+offset
J target	//跳转到target

```



### 编码前设计

结合教程的参考设计和mips，我们将中间代码分类：

- 变量定义。

- 二元运算。两个源操作数，一个目标操作数。
- 一元运算。一个源操作数，一个目标操作数。
- 偏移寻址。访问数组元素
- 读写内存。
- 函数相关。定义、调用
- 跳转。条件跳转和无条件跳转

- 输入输出

```
= ADD
- SUB
MUL
DIV
MOD
NOT
```

每一个中间代码都是一个对象，我们将其封装成类`MiddleCodeItem`

有一个中间代码的列表类`MiddleCode`，存储所有的中间代码，并进行中间代码的生成。

在`Visitor`遍历代码时生成中间代码并添加进入列表

下面一步步进行分析与设计：

- 变量定义

  全局变量，局部变量，字符串常量

  对于`int a = 1`分为两步，`int a;`和`a=1`。因此可以将此处的操作分为两个`DEF_VAL`和`SET_VAL`。**这样设计不好，由于会有const的存在，所以最好就一步到位，不然会有点歧义？因此这一步就直接变为`DEF_VAL 1 a`**

  对于全局变量和常量来说，值是需要提前就直接算好的，但是对于局部变量来说，值是需要写成mips在运行时执行的。

  对于数组来说不太好直接赋值，所以以繁化简。如对于`int a[10] = {1, 2}`，就分为`int a[10]`和`a[0]=1`和`a[1]=2`三步。因此此处的操作可以分为`DEF_ARR_BEGIN`，`SET_VAL`和`DEF_ARR_END`

  ```
  op		x		y		z
  DEF_VAL	1				a
  DEF_ARR_BEGIN			a[10]
  DEF_ARR_END				a[10]
  SET_VAL	1				a
  ```

- 一元计算

  ```
  a = 10;
  > ASSIGN a, 10		=
  ```

- 二元计算

  ```
  a = b + c;
  ADD b, c, a	+
  SUB			-
  MUL			*
  DIV			/
  MOD			%
  GT			>
  GE			>=
  LT			<
  LE			<=
  EQ			==
  NE			!=
  ```

- 偏移寻址

  ```
  a[10]
  OFFSET t1 10(a)
  ```

  这块还没想好怎么做。

- 读写内存

  ```
  LOAD, address, dst
  SAVE, address, src
  ```

- 函数相关

  主要包括三部分，函数名、函数参数、函数体

  由于函数跳转的时候是跳转到函数体执行，

  ```
  int func1(int a, int b)
  {
  	return c;
  }
  
  FUNC_BEGIN func1
  FUNC_END func1
  
  
  RETURN c
  ```

- 跳转

  对于跳转指令来说，只会有这些情况会跳转：1. 函数调用 2. 循环 3. 条件分支。将这几种的入口封装为一个类`BasicBlock`，其具有`Label`属性，其中间代码就是label

  ```
  JUMP label
  EQZ_JUMP var label	//如果var为0则跳转到label
  ```

对于每个类别的中间都写为一个类，都继承`MiddleCodeItem`类，成员就是其操作数，重写每个类的输出，即对应的中间代码。

**整体设计**

中间代码管理器存着所有的全局变量，全局数组，字符串，函数

| 类型     | OP                       | src1                 | src2        | ret        | 说明                                                         |
| -------- | ------------------------ | -------------------- | ----------- | ---------- | ------------------------------------------------------------ |
|          | GLOBAL                   | VAR_NAME/ ARRAY_NAME |             | VALUE      | 全局变量直接将他的值列出来                                   |
| 函数相关 | FUNC_BEGIN               |                      |             | FUNC_NAME  |                                                              |
|          | FUNC_END                 |                      |             | FUNC_NAME  |                                                              |
|          | CALL                     |                      |             | FUNC_NAME  |                                                              |
|          | PARAM                    |                      |             | VAR_NAME   | 形参的名字                                                   |
|          | PUSH_PARAM               |                      |             | VAR_NAME   | 如果是变量，就拷贝个tmp，然后push tmp。如果地址或者常数，就直接push |
|          |                          |                      |             |            |                                                              |
|          |                          |                      |             |            |                                                              |
|          |                          |                      |             |            |                                                              |
| 定义相关 | DEF_VAR                  | (VALUE)              |             | VAR_NAME   | 定义局部变量                                                 |
|          | ASSIGN                   | VALUE                |             | VAR_NAME   | 非数组变量的赋值，a = 8;                                     |
|          | DEF_ARRAY<br />END_ARRAY |                      |             | ARRAY_NAME | 定义局部数组                                                 |
|          | OFFSET                   | ARRAY_NAME           | var(字节数) | ADDRESS    | 数组元素的赋值<br />a[8] = 1;<br />OFFSET a 32 T<br />STORE 1 T |
| 内存相关 | STORE                    | VALUE                |             | ADDRESS    |                                                              |
|          | LOAD                     | ADDRESS              |             | VAR_NAME   | a[8];作为右值时，是需要返回值的<br />OFFSET a 32 T<br />LOAD T T2(返回值) |
| 计算相关 | ADD                      | src1                 | src2        | target     | 类似于Mips的设计                                             |
|          | SUB                      |                      |             |            |                                                              |
|          | MUL                      |                      |             |            |                                                              |
|          | DIV                      |                      |             |            |                                                              |
|          | MOD                      |                      |             |            |                                                              |
|          | ASSIGN                   | src1                 |             | target     |                                                              |
|          | POSITIVE                 |                      |             |            | 即unaryop的正号                                              |
|          | NEGATIVE                 |                      |             |            |                                                              |
|          | NOT                      |                      |             |            |                                                              |
| 跳转相关 | JUMP                     |                      |             | LABEL      |                                                              |
|          | JUMP_EQZ                 | src                  |             | LABEL      | 如果src为0时跳转到LABEL                                      |

全局变量和常量在编译时就计算出其值，由于这块没有涉及到错误处理，就直接单独写个计算类`Calculate`进行计算。



### 编码时细节

- **表达式具体值的计算**。在错误处理中只考虑了维度，没有考虑表达式的具体值、变量的具体值、数组的维度值。

  新增`Calculate`的类，其中的静态方法用于计算`Exp`的值。

- **与错误处理兼容**。在计算表达式具体值的时候，由于错误处理和计算是分开的，所以可能导致对错误的代码进行计算，会出错。比如下面这段代码，错误处理是在`visitInitVal`中的，即时有错误还是会进行计算。

  ```cpp
  visitInitVal(varDef->initval);
  int x = Calculate::calcExp(varDef->initval->exp);
  ```

  太傻了，纠结这个问题纠结了很久。在`visitInitVal`中正常的添加错误即可，同时在`visitInitVal`函数返回计算值就行，因为有错误的话就只会打印错误了嘛。因为这里其实只会涉及到`UNDEFINED`的问题，所以不用担心，遇到错误随便返回个值就行。

- **constDef和varDef**。怎么处理0呢？如果`a[10] = {1,2}`时，局部变量的话需要每个都赋值0吗？

- **局部数组的初始化**。首先是`DEF_ARR`，之后进行赋值。`OFFSET`通过偏移找到需要赋值的地址，然后`STORE`保存。可能这个会是变量，那这时就需要

- **局部变量的初始化**：不能直接计算。有可能是`getint()`或者是函数调用，需要在运行时计算。由于在处理时，会遇到函数可能返回`int`或是`ValueSymbol`的情况，考虑新建一个类，是立即数和符号的父类，记为`Intermediate`。然后用类似于递归下降的思路，逐步生成中间代码。同时，局部变量的初始化可能会出现`int a = b[0]`这种情况，在处理`LVal`时需要使用`OFFSET`和`LOAD`先得到`b[0]`，然后`def`。

  比如：
  
  ```cpp
  // 入口。其中sym是中间计算最后返回的操作数，可能是立即数，可能是valueSymbol。
  auto sym = visitExp(varDef->initval->exp);
  // 如果visitExp的值是立即数
  if (dynamic_cast<Immediate*>(sym) != nullptr) {
      auto def = new MiddleDef(MiddleDef::DEF_VAR, symbol, dynamic_cast<Immediate*>(sym));
      curBlock->add(def);
  }
  // 如果是ValueSymbol，即 DEF_VAR b a，将b的值赋给a，但由于b的值还未确定
  else {
      auto def = new MiddleDef(MiddleDef::DEF_VAR, symbol, dynamic_cast<ValueSymbol*>(sym));
      curBlock->add(def);
  }
  
  // 中间计算，以addExp为例，mulExp同理。逐步计算，逐步生成中间代码。其中getTempName是得到临时变量名字
  Intermediate *Visitor::visitAddExp(AddExp *addExp) {
  
      auto res = visitMulExp(addExp->mulExps[0]);
  
      for (int i = 0; i < addExp->ops.size(); i ++ ) {
          auto op = addExp->ops[i];
          auto middleCodeType = op->tokenType==Token::PLUS ? MiddleBinaryOp::ADD : MiddleBinaryOp::SUB;
  
          auto src1 = res;
          auto src2 = visitMulExp(addExp->mulExps[i + 1]);
  
          res = new ValueSymbol(getTempName());
          auto middleCode = new MiddleBinaryOp(middleCodeType, src1, src2, res);
          curBlock->add(middleCode);
      }
  
      return res;
  }
  ```
  
- **If语句的短路求值**：一开始没什么思路，看了助教讲的之后豁然开朗。

  1. 进入cond前，定义好trueLabel和falseLabel
  2. `LAndExp`接受`falseLabel`，只要有错就直接跳到`falseLabel`；`LOrExp`接受`trueLabel`，只要有对就直接跳到`trueLabel`。
  3. 以`LAndExp`为例，每执行一个`visitEqexp`就生成一个`JUMP_EQZ  (visitEqexp的返回值) falseLabel`的中间代码。

- **for语句**：

  1. 生成`loopBlock`和`endFor`，`cond`的trueLabel就是`loopBlock->label`，falseLabel就是`endFor`。
  2. `visitCond(cond, null, endFor);`
  3. `visitBlock`
  4. 最后`jump`回到`loopBlock`

- **数组元素的赋值语句**：由于我取数组元素时会使用`visitLVal`，这时会将数组元素的值`LOAD`存到一个临时变量中，而正确的应该是类似于数组的定义的方式，使用`STORE`某个值到这个地址的方式。也就是说，当数组元素作为左值时的赋值语句，需要与在右部时的处理不同。

## 目标代码生成

### 编码前设计

一个`MipsGenerator`类存放目标代码并生成，将每种目标代码设计为一种类，都继承自`Instruction`类

**内存管理**：（一开始没想好，后面边写边完善）

对于`symbol`的地址，之前并没有处理，在中间代码生成部分为每个`symbol`得到其在符号表中的地址

- 常量：不存，直接通过符号表查询。常量数组和变量处理方式一样。
- 字符串常量：从`.data`开始存
- 全局变量：从`$gp`开始存。
- 参数：前4个参数存储在参数寄存器`$a0~$a3`中，序号大于4的则以`$fp`为栈底，在内存中向上增长
- 局部变量：以参数区的栈顶作为局部变量区的栈底，向上增长
- 临时变量：以局部变量区的栈顶作为临时变量区的栈底，向上增长；当一个临时变量被使用后立即释放
- 局部变量：如果寄存器有位置放置在寄存器中其余则均放置在栈中，且进入函数前，就会为每个函数在栈中分配空间，该空间大小为其中间代码所包含的所有临时变量和局部变量的大小且该大小以及它们相对于函数栈针的偏移量会在生成汇编代码前通过递归遍历符号表计算得出，即栈针只在函数调用前后上下移动一次，在函数执行过程中不会移动，只会通过偏移量计算出栈中变量的位置进行寻址

sp在函数的栈底，数据向下增长，访问该函数的元素的地址时，就是`SP_ADDRESS-symbol.address`，但由于可能会有临时变量，**之前并没有分配临时变量的内存**，但是在操作时是需要压入栈中的，所以需要一个`curStackSize`来记录当前函数的栈的大小，如果有临时变量的话，就也给他压入栈中。

当调用函数时，就需要改变$$SP_{ADDRESS}=SP_{ADDRESS}-curStackSize$$ 

恢复时，就加回去。 

![image-20231111131806029](./设计文档.assets/image-20231111131806029.png)

在`translateFunc`时，首先设置`curStackSize`表示当前函数的栈的大小，其中的参数向下增长，因此符号的起始地址就是`$sp-symbol.getAddress`，如果是数组，就是需要向上`+offset`。

**寄存器管理**：暂不考虑高级的寄存器分配，现在就简单地遍历所有的可用寄存器，如果有空闲就分配这个寄存器。

**大体流程**：遍历中间代码阶段生成得到的`字符串、全局变量、函数`，中间代码是存在`函数中的basicblock`中的，所以遍历其中的`middlecode`，根据`middlecode`的类型进行翻译。

**翻译MiddleDef**：target可能是普通变量，src可能是立即数，可能是全局变量，可能是局部变量。首先给target分配一个寄存器，src分配一个寄存器或返回已分配的寄存器。

- 如果是立即数，就直接`li`
- 如果是全局变量，就`lw $src offset($gp)`
- 如果是局部变量，就`lw $src offset($sp)`

**翻译UnaryOp, BinaryOp**：这部分比较简单，就简单地翻译中间代码即可

**翻译Offset**：这部分涉及到了数组的操作。

```
OFFSET 4 a T0
->
T0分配一个寄存器$t0
addu $t0 $sp (offset+a的偏移地址) 
addu $t0 $gp (offset+a的偏移地址)
```

**翻译lw**：如果涉及到立即数，就需要先加载下立即数。由于在中间代码时已经处理了OFFSET，所以`lw`和`sw`的偏移都是0就行

```
STORE 1 T0	(T0是地址)
sw 1 0(T0)
```

**翻译Jump**：简单

**翻译FuncCall**：

1. 保存寄存器的值
2. 保存`$ra`的值在`0($sp)`中
3. 移动`$sp`到被调用函数栈底，即`$sp=$sp-curStackSize-4`(4是由于要为`$ra`留空间)
4. 将实参按顺序压入栈中
5. `jal`调用函数
6. 回栈，操作`$sp`加回去
7. 恢复`$ra`，将`0($sp)`中的取出来
8. 如果有返回值的话，将返回值存到对应寄存器中

**函数参数传数组**：

- 形如`void func(int b[])`

  传入实参时，调用时`func(x)`，如果判断x是指针，就将他的类型设置为`POINTER`，得到其在当前函数栈中的地址偏移值，在压入参数的时候，如果判断到时`POINTER`类型的，计算出指针指向的实际的内存位置，将这个值压入参数的栈中。

  在被调用函数中使用形参时，他的类型是`FuncFParam`，地址的偏移也是在中间代码生成时就已经得到的，在给形参的值分配寄存器时会利用`$sp`来`load`，如果形参是数组的话，此时`load`到寄存器中的是数组的地址，比如使用`b[0]`时，如果是局部变量数组，就是算出他相对于`$sp`的偏移，如果是形参数组的话，就需要先将`b`的地址放入寄存器，然后`load $t0 offset(b)`来得到`b[0]`

- 如果传递的参数是参数数组的话，参数栈的位置的值就是数组的实际地址

**寄存器的保存**：

### 编码时细节

对之前的中间代码进行了调整：

- 在生成中间代码时，计算每个symbol的大小和偏移地址

- 为了计算函数的活动区需要的大小，每个`Func`中记录他的符号表`funcSymbolTable`，在函数定义的过程中，维护这个`funcSymbolTable`，并可以计算出其大小，同时可以求得每个symbol的偏移地址

- 如果中间代码直接出现`PUSH_PARAM`，那么在翻译成目标代码时，就无法知道将要调用的是哪个函数，栈空间无法确定。因此需要有一个开始调用函数的标记`TO_CALL`。同时，`PUSH_PARAM`分开写的话无法判断偏移的位置，挺麻烦的，因此修改为将所有的参数都写在call中，那也不需要`TO_CALL`，就一个`CALL`就行。

- `void`函数也需要有`return`语句，不然无法输出`jr $ra`

- 局部变量的地址需要从`4($sp)`开始存，`0($sp)`的位置留给`$ra`存。这样的话，而全局变量的偏移还是应该从0开始的，并且全局变量的地址起始值变成了

- 中间代码一开始忘记处理`break`和`continue`了。

  ```
  每进入一层循环，loopLabels就push进stmt2 begin的位置和endLoop
  每退出一层循环，就删去最后两个label
  当前循环中，易得，continue的话就是jump到loopLabels.size()-2，break的话就是loopLabels.size()-1
  {0
  	{2
  		{4
  		continue;	// jump 2
  		break;		// jump 3
  		}5
  	}3
  }1
  
  {0
  	{2
  		{
  			...不用考虑，因为已经弹出数组了
  		}
  		{4
  			continue;
  			break;
  		}5
  	}3
  }1
  ```

  

**临时变量的考虑**：之前没有考虑到临时变量的具体处理，临时变量并没有定义，内存中没有空间。打算在中间代码阶段生成临时变量时就做好记录，在生成目标代码时统一处理分配内存地址。

**输出字符串**：虽然可以使用`la`来加载标签地址，但是试了下会慢些，感觉可以直接通过`li`的方式得到地址。这就需要存储字符串的地址。

当使用`asciiz`时，每个字符串结尾有一个字节的`\0`

```
a: .asciiz "aa"
b: .asciiz "a"
的存储就是0x61006161
```

在得到全局变量的最大地址后，设置字符串的地址。字符串的大小需要注意的是，形如`\n`的转义字符只有一个字节，直接使用`.size`不行，需要单独编写函数，文法规定只会出现'\n'转义符，所以还好。

**数组传参**：

```
// 验证参数二维数组传参
int func(int x[]) {
    int a = 1;
    printf("in func %d\n", x[1]);
    return x[a];
}
int func2(int x[][2]) {
    int a = 1;
    printf("in func2 %d\n", x[1][1]);
    return func(x[1]);
}

int main() {
    int x[2][2] = {{1,2},{3,4}};
    int a = func2(x);
    printf("a is %d\n", a);
    return 0;
}
```

### 痛苦DEBUG

辅助测试：

>  在`for`循环中，全局变量的值改变后，没有写入内存中

跳转前保存所有寄存器

> C836: 多次调用之后，第一个输出值x发生了变化

在执行完调用函数之后，应该清空其寄存器，防止错误的写回。

> C837：`continue`和`break`跳转的标签位置错误。已改正
>
> 函数调用的问题：
>
> ```c
> int func(int a){
>     printf("a is %d\n", a);
>     return 0;
> }
> 
> int main(){
>     func(1);
>     return 0;
> }
> ```
>
> ，由于我的中间代码中，当判断到调用函数的返回值是int时，就新建一个临时变量，充当接受到的返回值。问题在于，我在函数一开始的时候保存所有的寄存器，此时这个临时变量返回值为0，就会覆盖掉传入的a的值，因此为0。

调用函数前保存所有寄存器，调用函数之后清空寄存器，跳转前保存所有寄存器，函数结束前清空所有寄存器，除了函数的basicblock外loop和branch的block都要保存寄存器。修改了保存寄存器的位置之后输出正确。

> C838: 参数如果是普通变量的时候，不应该写回内存中。！！！错啦，是可以写回的！！！普通变量的处理和实际变量的处理一样
>
> ```c
> int func(int a){
>     a = a - 1;
>     return a;
> }
> 
> int main() {
>     int x = func(7);
>     printf("x = %d\n", x);
>     return 0;
> }
> ```

将普通参数的类型设置为一般的变量就ok了

> C845：出错的情况：下面这段代码，输入一个数后，打印i=2。而如果注释掉`k=getint()`，那就正常了。
>
> 找到bug了，此时continue后，应该执行`i=i+1`，跳转前，保存并且清空了所有的寄存器，但是我在循环内部跳转到`stmt2`时没有加跳转语句，而是接着执行的，这就会导致`continue`后`i`可能被分配到错误的寄存器。
>
> ```
> for(i=0; i < 5;i=i+1 {
>     printf("i is %d\n",i);
>     k=getint();
>     x = 1;
> 
>     if(x>0){
>         continue;
>     }
>     i=i+1;
> }
> ```

在循环体内部到`forStmt2`之间加上`saveAllRegisters()`保存并清空所有寄存器，或者加上一条跳转语句。我选择后者，虽然会多一条jump，但是前者在中端貌似没法实现，后端也不太好实现。

> B815：全局二维数组没有初始化时应该为0，忘了设置了

> **B818：**看了很久的mips才看出来！！！如果出现k=k+1，此时的1需要写入寄存器中，另外，他替换掉的刚好就是k所在的寄存器。下面是我执行的代码片段，首先k得到属于他的寄存器，设为`$t1`，这时，1也刚好得到的是寄存器`$t1`，那么这时就会导致计算时`rd=1+1`的情况出现！！！
>
> ```c++
> // t1不是立即数，t2是立即数
> else if (t2 != nullptr) {
>     rs = RegisterAlloc::getInstance().allocRegister(dynamic_cast<ValueSymbol*>(src1));
>     rt = RegisterAlloc::getInstance().allocRegister(new NumSymbol(t2->value));
>     rd = RegisterAlloc::getInstance().allocRegister(dynamic_cast<ValueSymbol*>(target), false);
> ```

1. 寄存器写回时覆盖了基地址的值，`a[i]`计算`offset`的时候，会将a的地址值赋值给寄存器，在写回时，就将这个地址值写回到了`a[0]`的位置。因此，此时的对应关系是**一个寄存器对应着一个数组，这时不将该寄存器写回！！！因此在写回时判断symbol的维度，大于0则不写回**
2. **二元运算出现的寄存器符号覆盖的问题**：添加新的分配函数，如果此次将要分配的函数和指定寄存器相同，则分配的位置++。

> B823：continue相关错误。在每次跳转前保存所有寄存器。所以指令的顺序是
>
> - save reg
> - save reg
> - jump
>
> 在continue时，会生成一个jump指令，跳转到forstmt2的label。在`forstmt2`之后紧接着还有一个`jump to beginLoop`的跳转，此时会把旧的寄存器中的值写回内存中。这就是错误的原因。
>
> ```c
> int main() {
>     int a = 0;
>     for (; a < 8;) {
>         if (a == 2) {
>             a = a + 1;
>             continue;
>         }
>         a = a + 1;
>     }
>     return 0;
> }
> ```

如果判断`stmt2`为空的话，那么`forstmt2`的label就和`beginloop`一样，这样，在`continue`时，就会直接跳转到`beginLoop`。

> A806：形如下面这段代码中，问题主要出在a[1] = func()。我在中端翻译时是先visitLVal再visitExp，导致中间的函数调用会差在中间，造成寄存器的问题。调换顺序即可解决。
>
> ```c++
> int func(){
>     return 1;
> }
> int main(){
>     int a[2] = {1,2};
>     a[1] = func();
>     return 0;
> }
> ```

**不足之处**：

- 中端和后端一起写的，耦合性太大了，并且由于没有写虚拟机测试中端，导致在写后端的时候频繁改动中端，导致牵一发而动全身，shi上堆shi。
- 错误处理bug

```
RE:
int func2(int d[]) {
    int b[2] = {11,22};
    return func(x);
}
```

### 编码时想到的优化点

- 对于立即数，我是用`li`，他放到了寄存器里，但有些支持立即数运算的op不需要
- `int b=a+1`，会开个临时变量，然后存到临时变量中去，再move
- 临时变量如果后面不需要再用了，在`clearRegister`时需要再保存回临时变量。
- 当把数组中的一个元素传给函数调用时，中间代码会先取值，然后再传值。因为可以直接得到地址，压入参数时可以考虑直接`lw`地址。

- for循环中，现在是每个循环都要计算下cond的条件值
- 短路求值会多跳一次。

- for前的貌似不需要全部保存寄存器？

  ```
  # DEF_VAR 0 sum[0xc]
  ### sum -> $t6
  li $t6 0
  # save to value sum
  sw $t6 -12($sp)
  # save to value i
  sw $t5 -8($sp)
  LABEL_28:
  
  int i = 0, sum = 0;
  for (;i < Bound[0];) {
      sum = sum + a[i];
      i = i + 1;
  }	
  ```


### 总结

中间代码加上目标代码差不多做了两周，从一开始不知道怎么进行内存管理，寄存器分配（虽然现在还是没搞寄存器分配），无从下手，在学习了其他编译器之后，慢慢地才有了思路。

一开始觉得llvm有点复杂，不如四元式简单直接，就直接上手四元式了，但是在设计的过程中遇到了不少的问题，中间也调整了很多次四元式的结构，形式上比较贴近mips的设计，在生成目标代码时就会容易些。另外，在写中端时很多地方都没有考虑到，因为实在不知道后面会怎么处理，比如函数调用时传递数组，参数变量的使用，二维数组传参一维数组等等，这些都是在写中端时，我想考虑但是不知道怎么写的地方就忽略了，事实证明这些点也是在写目标代码生成时遇到的大问题。最后，在勉强生成了一版能看的中端后，虽然还存在不少bug，但我直接开始写生成mips了。这也是四元式的一个大弊端：不知道自己写的对不对！虽然可以写个虚拟机来模拟运行，但是我觉得有点麻烦就没写了。而其他选择llvm->mips的同学就可以很好地检测自己中端的正确性。

虽然中端写的挺快的，写目标代码的时候就遇到了不少问题！在写后端的同时改中端！甚至改符号表等结构，非常的痛苦！牵一发而动全身，对此我这么评价四元式，自己拉的shi，还要给他捏一个好看的形状，哪有问题就东拉一点，西拉一点。可能是由于我一开始没有设计好，但这确实是我自己写四元式的感受，导致代码中出现了不少`if`，或者一个类只针对某一种情况的`特有变量`。这部分最难de的bug就是寄存器相关的，什么时候保存寄存器，什么时候清空寄存器不保存，怎么分配寄存器等等，这些都是我在一开始对寄存器的分配云里雾里的时候瞎写的，导致后面这块成了重灾区！在痛苦DEBUG的过程中，很多时候只能一行一行的看汇编代码来debug，一de就是一两个小时，不过虽然痛苦，写完整个目标代码生成之后对mips代码就非常熟悉了，对于程序运行的底层也更加理解了，更加理解了内存分配，寄存器管理等等内容。

（后面的优化就随缘咯）

## 优化

原始版：

![image-20231114203803353](./设计文档.assets/image-20231114203803353.png)

**重构了中端的基本块！！！一开始划分错误**

![image-20231119151839249](./设计文档.assets/image-20231119151839249.png)

### 中间代码优化

#### 可能的优化

中间代码中的这些代码

```
MUL 10 10 T0
ADD T0 100 T1
ASSIGN T1 a
```

#### 常量计算

如果可以直接将值计算出来时，就直接计算出来。在`visitExp`中，尝试计算一下，如果可以计算，那么就返回这个值，如果出错了，就`catch`这个报错，接着正常输出计算的中间代码。

或者是变量的值在全局都没有发生过变化的，也可以当做常量。新开一个类`NoChangeValue`，定义时将变量都存进去，维护一个`<ValueSymbol, int>`的键值对。当在翻译的时候变量出现在了等式左边，那就将其从表里拿走。中间代码翻译结束后，遍历所有的中间代码，将其中没有改变的变量替换为其值。

*TODO：如果传入的实参是全局没有发生过变化的量，也可以替换，还没做。*

```c
const int a[4] = {1,2,3,4};

int main() {
    int b = a[0] + 5;
    printf("%d", a[1]);
    printf("%d", a[1] * a[2]);
    return 0;
}
```

原来的中间代码：

```
######### Middle Code Start #########
GLOBAL VALUE: 
ARRAY a 1,2,3,4
GLOBAL STRING: 
###########################
###### BEGIN_main ######
###### func_size is 4######
Func_main:
### BLOCK_FUNC BEGIN
LABEL_1:
OFFSET 0 a T0
LOAD T1 T0
ADD T1 5 T2
DEF_VAR T2 b[0x4]
OFFSET 4 a T3
LOAD T4 T3
PRINT_INT T4
OFFSET 4 a T5
LOAD T6 T5
OFFSET 8 a T7
LOAD T8 T7
MUL T6 T8 T9
PRINT_INT T9
return 0
### BLOCK_FUNC END
###### END_main ######

######### Middle Code End #########
DIV 	: 0
MULT 	: 1
JUMP/BRANCH 	: 0
MEM 	: 4
OTHER 	: 15
FinalCycle : 31.0
```

现在的中间代码：

```
######### Middle Code Start #########
GLOBAL VALUE: 
ARRAY a 1,2,3,4
GLOBAL STRING: 
###########################
###### BEGIN_main ######
###### func_size is 4######
Func_main:
### BLOCK_FUNC BEGIN
LABEL_1:
DEF_VAR 6 b[0x4]
PRINT_INT 2
PRINT_INT 6
return 0
### BLOCK_FUNC END
###### END_main ######

######### Middle Code End #########
DIV 	: 0
MULT 	: 0
JUMP/BRANCH 	: 0
MEM 	: 0
OTHER 	: 9
FinalCycle : 9.0
```

第二种优化：

```
int func(int a, int b){
    return a;
}

int main(){
    int x = 10;
    int y = 10;
    y = 100;
    y = func(x, y);
    printf("y is %d\n", y);
    return 0;
}
```

| DIV  | MULT | JUMP/BRANCH | MEM  | OTHER | FINAL CYCLE |
| ---- | ---- | ----------- | ---- | ----- | ----------- |
| 0    | 0    | 2           | 10   | 22    | 56          |
| 0    | 0    | 2           | 9    | 23    | 54          |

但是实际上，这部分对于竞速测速没有任何优化。

![image-20231115124200380](./设计文档.assets/image-20231115124200380.png)

#### 循环优化

#### 数据流图建立

<img src="./设计文档.assets/image-20231116132940343.png" alt="image-20231116132940343" style="zoom:50%;" />

虽然之前已经是按照`basicblock`划分的基本块，但是当时的划分有一点随意，并没有按照基本块的规范划分，这里再重新规范一下。每个函数`Func`中包含一个`funcbody`的基本块，在这个基本块中有多个基本块。各个基本块之间有前驱和后继关系。

基本块的在下面的情况会发生更新：

- if语句。如果出现if时，首先确定好三个基本块，`ifBlock`,`elseBlock`,`endBlock`。在当前基本块下翻译`cond`，然后翻译下面的block时设置`curBlock`的值。
- for语句。如果出现for时，首先确定好四个基本块， `condBlock`, `bodyBlock`, `stepBlock`, `endBlock`。在当前基本块下翻译`forStmt1`，然后接着翻译下面的block。

**这里重构了中端的基本块！！！重构后，每个基本块的结尾都是`jump anotherBlock`方便建立数据流图**

#### 无用代码删除

在建立了新的基本块后，发现有不少跳转都是可以合并的，如果跳转到的基本块只有一条跳转语句，那么就直接跳转到下一个基本块，用一个`while`循环不断遍历。

可以删除的无用代码：

- `jump`的多次跳转可以合并的情况
- 不会被经过的基本块。（这里，不能简单地判断前驱为0，因为可能存在一个链表）

同时，在我的中间代码中，存在着

- `JUMP后仍有代码`的情况，将`JUMP`后面的无用代码删除
- 基本块最后两个语句是`JUMP_NEZ`和`JUMP`两种情况，这两种`JUMP`的`target`都需要设置。



>  在删除`std::vector<BasicBlock*> basicBlocks`中指定的`basicBlock`时遇到了问题！！！

```c
std::vector<int> numbers = {1, 2, 3, 4, 5};
// 错误的示例：在循环中使用 erase()
for (auto it = numbers.begin(); it != numbers.end(); ++it) {
    if (*it % 2 == 0) {
        numbers.erase(it);  // 这里会导致迭代器失效
    }
}

// 正确的示例：使用有效的迭代器和更新迭代器
for (auto it = numbers.begin(); it != numbers.end(); ) {
    if (*it % 2 == 0) {
        it = numbers.erase(it);  // 使用 erase() 返回的有效迭代器
    } else {
        ++it;  // 更新迭代器
    }
}
```

在进行了上述操作后，中间代码的数量大大减小。

![image-20231119165004713](./设计文档.assets/image-20231119165004713.png)



#### 活跃变量分析

<img src="./设计文档.assets/image-20231119214244319.png" alt="image-20231119214244319" style="zoom:67%;" />

<img src="./设计文档.assets/image-20231119214428477.png" alt="image-20231119214428477" style="zoom:67%;" />

数据流方程：
$$
in[B]=use[B]\cup(out[B]-def[B])\\
out[B]=\cup_{B的后继基本块}in[P]\\
def[B]:变量在B中被定义或赋值先于任何对他们的使用，先定义后使用\\
use[B]:变量在B中被使用先于任何对他们的定义，先使用后定义
$$

**算法流程：**

1. 初始化：第一个基本块的$out[ENTRY]=\Phi$ ，所有的基本块的输出$out[B]$ 也是$\Phi$ 
2. 计算每个基本块的$kill[B]$和$gen[B]$
3. 根据$in[B]=\cup_{B的前驱基本块P}out[P]$ ，$out[B]=gen[B]\cup(in[B]-kill[B])$ ，计算每个基本块的$in[B]$，$out[B]$。如果某个基本块计算得到的$out[B]$与之前计算得到的不同，就循环2。

**实现**：

- 集合中的每个定义点，将其下标映射为一个二进制位数中的一位。
- $\cup$相当于是或运算，$-$相当于是将后者取反后，与前者按位与。
- $kill[B]$：**注意考虑的范围是这个函数中的所有基本块中**，比如B中有一个`d1:a=1;`，在另一个基本块中有一个`d3:a=3`，那么$kill[B]={d3}$ 

- $gen[B]=gen[d_n]\cup(gen[d_{n-1}]-kill[d_n])\cup...\cup(gen[d1]-kill[d2]-kill[d3]-...-kill[d_n])$



在函数中，每个`symbol`对应一个定义集`DataFlowDef`。遍历所有的block并填充这个定义集

每个代码，得到他的$kill[d_i]$和$gen[d_i]$ 






#### 死代码删除

死代码删除是建立在**活跃变量分析**基础之上的。

















