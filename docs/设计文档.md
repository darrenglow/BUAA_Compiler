# 编译实验

## 文法解读

### 问题

![image-20230912155519043](C:\Users\66418\AppData\Roaming\Typora\typora-user-images\image-20230912155519043.png)

这里怎么通过文法来判断是不是有return Exp呢？

### 实验

![image-20230912150221098](C:\Users\66418\AppData\Roaming\Typora\typora-user-images\image-20230912150221098.png)

完成A级：

```c
int a = 1, b = 0, c = 1;
if (a && b)
{
    printf("&& branch")
}
else if (a || b)
{
    printf("|| branch\n")
}
if (a && b || c)
{
    printf("&& || branch");
}
```

完成B级：

**注意：常量数组不能当做参数传入函数**

```c
//常量定义

//函数形参

//左值表达式

//函数实参
```

完成C级：

```c
//常量定义。
//变量定义。VarDecl → BType VarDef { ',' VarDef } ';' 
//函数定义。 FuncDef → FuncType Ident '(' [FuncFParams] ')' Block
/*
int/void
() (...)
{} {...}
*/

//语句stmt的情况
//1. LVal '=' Exp ';'
//左值表达式 LVal → Ident {'[' Exp ']'} 
//exp->addexp(有无+-) -> mulexp(有无*/%) -> unaryexp(primaryexp, 函数调用, +-unaryexp) -> primaryexp(有括号的exp, 左值， 数字)
//b = (a / 1) * (a + 2) * (a % a) + a - 1 + f0() - f1(a) * f2(a, a);

//2. [Exp] ';'

//3. Block

//4. 'if' '(' Cond ')' Stmt [ 'else' Stmt ]
//Cond->LOrExp
//LOrExp → LAndExp
//LAndExp → EqExp
//EqExp → RelExp | EqExp ('==' | '!=') RelExp
//RelExp → AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp

//5.'for' '(' [ForStmt] ';' [Cond] ';' [ForStmt] ')' Stmt 
//6.continue, break
//7.getint
```

## 词法分析

| 单词名称         | 类别码     | 单词名称 | 类别码   | 单词名称 | 类别码 | 单词名称 | 类别码  |
| ---------------- | ---------- | -------- | -------- | -------- | ------ | -------- | ------- |
| **Ident**        | IDENFR     | !        | NOT      | *        | MULT   | =        | ASSIGN  |
| **IntConst**     | INTCON     | &&       | AND      | /        | DIV    | ;        | SEMICN  |
| **FormatString** | STRCON     | \|\|     | OR       | %        | MOD    | ,        | COMMA   |
| main             | MAINTK     | while    | WHILETK  | <        | LSS    | (        | LPARENT |
| const            | CONSTTK    | getint   | GETINTTK | <=       | LEQ    | )        | RPARENT |
| int              | INTTK      | printf   | PRINTFTK | >        | GRE    | [        | LBRACK  |
| break            | BREAKTK    | return   | RETURNTK | >=       | GEQ    | ]        | RBRACK  |
| continue         | CONTINUETK | +        | PLUS     | ==       | EQL    | {        | LBRACE  |
| if               | IFTK       | -        | MINU     | !=       | NEQ    | }        | RBRACE  |
| else             | ELSETK     | void     | VOIDTK   |          |        |          |         |

### 编码前设计

```
Lexer/Lexer.h：定义Lexer类
Lexer/Lexer.cpp：类的函数具体实现
Lexer/Token.h: 定义Token类
```

`Lexer.cpp`： 

- 功能：读取文件，提取单词，返回单词串

- 元素：
  - `std::string token`：正在读取的token
  - `char c`：读取的字符
  - `int curLine`：当前行
  - `std::vector<Token*> tokens` ：所有的token

流程：

1. 读取文件
2. 每次先读取一个字符，再对这个字符进行判断，看是否需要进一步的处理。
3. 如果该次获取到了有效的字符串，根据这个字符串去查找他所属的`tokentype`，并将其加入到`tokens`中。
4. 最后输出时，将`tokens`输出到文件即可。

### 编码中的细节

**语言上的细节**：

- cpp中重载运算符需要使用友元的形式。

- `static`必须在类的外部定义

- `ifstream`

  ```c++
  class Lexer{
  private:
      std::vector<Token> tokens;
      std::ifstream& input;
  public:
      Lexer(std::ifstream& input_) : input(input_) {}
  };
  ```

  这里的input如果不是&就会报错，某种奇怪的原因，貌似是啥拷贝构造之类的。使用引用的方式就行。

- `const`放在函数后表示该函数不改变成员变量的值。

- `map.find()`函数

```c++
auto iter = str2type.find(str);
if (iter == str2type.end())	//找不到
{
    iter->second;	//得到str键对应的值
}
else {	//找得到
    
}
```

- `string.push_back`比`string+`快，因为`string+`会将后面的字符先构造成string对象。

**实现上的细节**

- 使用enum枚举Token，为了方便打印，将enum枚举的位置和tokenName的位置进行对应。
- 将`input`和`output`放哪的问题纠结了好一会，最后选择都在`main.cpp`中定义，在`lexer.cpp`中使用`extern`的形式使用，感觉这样很方便。
- 需要实现的`str2type`和`type2str`。后者一开始没有考虑到，因为要涉及到打印`type`。
- 对于换行的处理，每次读取一个字符，如果读到了换行符，就会将`curLine+1`
- **每次先读取一个字符**。意味着在每次`nextToken`开始的时候，`ch`就是已经在上一次循环最后读取到的。**很重要，忽略了的话就死循环了...**

### 总结

一开始感觉无从下手，一方面是第一次接触c++的项目，一方面是对于词法分析的要求还理解得不是很透彻。

我首先看了看c++项目的一般流程，学习了怎么使用`cmakelist`，以及在使用c++的类的时候的注意事项，还有很多语法上的细节都是在后面边做边搜的，感觉收获了不少了。

之后我在做之前先参考学习了课程组提供的pl0编译器的代码，以及其他优秀的编译器的设计，在广泛学习并构思后，我才开始了我的编码，感觉就会挺顺畅的。

## 语法分析

### 编码前设计

因为涉及到了对`tokenList`的操作，所以我在这里将之前设计的简单重构了一下，将`std::vector<Token*>`封装成了一个类`TokenList`，方便在`Parser`阶段调用类的方法进行操作

封装了`Parser`类，将`Lexer`解析得到的`tokenList`对象传入`Parser`中，执行`parse`方法开始递归下降解析。



1. 文法中存在左递归的文法，需要改写

```
MulExp -> UnaryExp | MulExp ('*' | '/' | '%') UnaryExp
MulExp -> UnaryExp { ('*' | '/' | '%') UnaryExp }

AddExp -> MulExp | AddExp ('+' | '−') MulExp
AddExp -> MulExp { ('+' | '−') MulExp }

RelExp -> AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp
RelExp -> AddExp { ('<' | '>' | '<=' | '>=') AddExp }

EqExp -> RelExp | EqExp ('==' | '!=') RelExp
EqExp -> RelExp { ('==' | '!=') RelExp }

LAndExp -> EqExp | LAndExp '&&' EqExp
LAndExp -> EqExp { '&&' EqExp }

LOrExp -> LAndExp | LOrExp '||' LAndExp
LOrExp -> LAndExp { '||' LAndExp }


```

2. Stmt的语法规则太复杂，可以新增非终结符，让结构更加清晰。

```
<AssignStmt> -> LVal '=' Exp
<ExpStmt> -> Exp
<BlockStmt> -> Block
<IfStmt> -> 'if' '(' Cond ')' Stmt [ 'else' Stmt ]
<ForStmt> -> 'for' '(' [AssignStmt] ';' [Cond] ';' [ForStmt] ')' Stmt
(原有的ForStmt改名为了AssignStmt)
<BreakStmt> -> 'break'
<ContinueStmt> -> 'continue'
<ReturnStmt> -> 'return' [Exp]
<InputStmt> -> LVal '=' 'getint' '(' ')'
<OutputStmt> -> 'printf''('FormatString{','Exp}')'
```

3. `MainFuncDef`和`FuncDef`类似，直接当做`FuncDef`来处理。
4. 考虑到将语法分析与后面的部分解耦，计划实现语法树。每个节点都是`Node`，因为是树，所以有`Node* parent`和`std::vector<Node*> children`的成员。
5. 因为`Node`可能是终结符和非终结符，所以具有两种成员，`Token* term`和`NoTerminal noTerm`

### 编码中的细节

- 要构建语法树
- `constdecl`和`vardecl`可以合并，用一个`isConst`来区分，同时`constdef`和`vardef`也可以合并。

- （不确定）`UnaryExp`中的`UnaryOp`我不知道包不包括`!`，同时如果想要判断是否是`PrimaryExp`，不知道怎么判断int，只好把这个写在`else`里面。

**----------------在与助教沟通后，对整体的语法树结构、以及其他设计进行了重构修改------------------**

- **不再使用`Node`来构建语法树，对于每种非终结符都设计单独的类，方便后续的处理，在`AST.h`中**
- 只将有具体含义的、重要的节点插入语法树中，而不是将所有的token都加入。
- 在输出结果时，对每种非终结符都重写其输出函数，在`AST.cpp`中实现。

- `Stmt`中的`LVal '=' Exp ';' `和`[Exp] ';'`和`LVal '=' 'getint''('')'';'`的判断。。。

```
 Exp → AddExp -> MulExp -> UnaryExp ->  '(' | LVal | Number | Ident '(' | '+' | '-' | '!'
 LVal -> Ident
 虽然Ident是重复的，但是可以使用Ident '('来特殊判断Exp
 
 剩下两个的话，可以先parseLVal()，再看后面的一个是不是'getint'。
```

- 像`LOrExp -> LAndExp { '||' LAndExp }`，一开始把`||`没有插入语法树，但是想想，还是得插入，并且得判断是不是`||`

- 为了控制输出，使用#define来控制

### 编码中错误

- 有些地方的换行符漏加
- 有处的指针未取值
- `UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')' `输出忘了`Ident`后面的部分
- 由于改写了文法取消了左递归，但是实际上还是需要写出来。

![image-20230924162510224](C:\Users\66418\AppData\Roaming\Typora\typora-user-images\image-20230924162510224.png)

- 将`AddExp->MulExp {( '+' | '-') MulExp}`中的+-当做了unaryop，但其实只是简单的Token.
- stmt的[exp]可以以`!`开头吗？我现在没用

### 总结

这部分花了我可能一周的时间，从学习知识到设计到编码，一开始不明白怎么构建语法树，只使用一个`Node`的方式来构建，并且把每个token都存入语法树中，工作量非常的大。好在咨询了助教，及时地对代码进行了重构，采用每种非终结符对应一个类的形式，构建语法树时也简便不少，提前设计好真的太重要了！！！不过现在的设计感觉还是有些繁琐，每个非终结符都对应一个`parse`和一个重载输出`<<`，每个文件都几百行代码，个人感觉不太优雅，可能可以把其中的某几部分合起来，但是没有再细细设计，直接简单粗暴地编写程序了。

不过由于对后续的任务不是很清楚，不知道现在这种语法树的构建是否有问题，可能还需要进行重构。

## 错误处理

### 编码前设计

为了处理错误，定义Error类，包括错误的类型和错误所在的行数

为了记录错误，定义ErrorTable类，Error对象的集合。

纵览所有需要处理的错误类型，一一进行分析：

- 非法符号ILLEGAL_FORMATSTRING：在词法分析时对FormatString进行判断。**词法分析**
- 名字重定义DUPLICATE_IDENT: 函数名、变量名在当前作用域重复定义，需要建立符号表进行判断。**符号表**
- 未定义UNDEFINED_IDENT：根据符号表，判断是否未定义。**符号表**
- 函数参数个数不匹配MISMATCH_PARAM_NUM：根据符号表，可以判断定义的函数参数个数，和调用的参数个数。**符号表**
- 函数类型不匹配MISMATCH_PARAM_TYPE：同上判断**符号表**
- void函数有不匹配的return。VOID_MISMATCH_RETURN。**符号表**
- 有返回值的函数缺少return。LACK_RETURN**符号表**
- 不能改变常量的值CHANGE_CONST**符号表**
- 缺少分号：LACK_SEMICN：语法分析阶段得到。**语法分析**
- 缺少右小括号LACK_RIGHT_PARENT：语法分析阶段得到。**语法分析**
- 缺少右中括号LACK_RIGHT_BRACK：语法分析阶段得到。**语法分析**
- print中格式字符与表达式个数不匹配PRINTF_MISMATCH_NUM。**符号表**
- 非循环块中使用break, continue BREAK_CONTINUE_OUT_LOOP。**符号表**

词法分析与语法分析可对部分错误进行判断，在遍历语法树的过程中建立符号表，并进行额外的错误处理。当检测到错误时，将错误添加入错误表中。结束时按照要求对错误表进行输出。

- 符号表：

  建立树形的符号表，方便管理

  对于符号表，在进入`CompUnit`, `Block`, `FuncDecl`时新建符号表，并以当前符号表作为父节点。

  插入符号：检测当前级符号表中是否有同名变量，有则报错。
  
  查找符号：从当前级符号表向上查找到最近的。

### 编码时细节

- 对于`ErrorTable`，设计为单例模式，这个类在词法、语法、后续的代码生成中均有出现。

- 由于之前设计了`popExpect`的函数，所以在处理`i, j, k`与语法相关的错误时，可以都放在这个函数中处理。

- **错误g**：在涉及到`return`时，由于只需要考虑最后一行是否有`return`，大大简化了操作，就获取到`block`的最后一个item然后判断即可。错误行号是`}`的位置，而我并没有记录这个值，在AST中重新添加。

- 对于`visitBlock`，如果是函数的{}，那由于需要考虑形参也作用在这个里面，就不重新建符号表了。而如果是stmt中的`block`，那就需要重新建符号表了。

- **错误f**：考虑函数的返回值是否是空，以及最后一行的`returnStmt`中是否有`exp`，如果同时满足，则报错。

- **错误d**：实参和形参的类型匹配，计算实参的维度时，由于实参是`exp`，

- 当`funcFParam`在函数体中出现时，符号表中是`FuncFParamSymbol`，但是我为了判断这个变量是否是常量，我并不知道这个符号是`FuncFParamSymbol`还是`ValueSymbol`，因此如果想判断是否是常量就很麻烦。因此，我采用了多态的动态绑定，将`isConst()`方法写在父类`Symbol`上，在`ValueSymbol`和`FuncFParamSymbol`类里分别实现，这样，即使只从符号表中获取到指向`Symbol`的指针，也可以通过`p->isConst()`来得到是否是变量。

- 同上，在`PrimaryExp::getDim()`中，如果用到了函数参数的维度，那么也需要从符号表中拿到，会遇到和上一点一样的问题。

  ```c++
  auto valueSymbol = dynamic_cast<ValueSymbol*>(Visitor::curTable->getSymbol(name, true));
  int realDim = (int)(valueSymbol->dims.size()) - formDim;   // 实际传入的维度
  ```

  应改成：

  ```c++
  auto symbol = Visitor::curTable->getSymbol(name, true);
  int realDim = (int)(symbol->getDim()) - formDim;   // 实际传入的维度
  ```

  在`Symbol.h`中对将`getDim()`写成虚函数，然后实现动态绑定

### 编码时错误

- 发现了词法分析中的错误，设置当前token的行数时，不应该一直用curLine，因为有些会读到换行符导致curLine变化，应该在一开始处理时就将`curLine`先记录下来。

- 发现了语法分析中的错误。`a;`这句话会判断为`assignStmt`。

  在`parseStmt()`时

  ```
  LVal '=' Exp ';'
  [Exp] ';'
  LVal '=' 'getint''('')'';'
  ```

  这几个的FIRST都有可能是`LVAL`，我一开始只考虑了1,3，第二种情况没有考虑。

  首先`parseLVal`，将难处理的`LVal`读取，在这时只有可能是`LVal`，其他的情况在之前的if中已经得到判断。之后根据后一个符号是否是`=`，如果是就再判断1,3，如果不是，就只会是`expStmt`。

- 当`visitFuncDef`时，因为我想要把`FuncFParamSymbol`存在`FuncSymbol`中，所以是在`visitFuncFParam()`之后才新建了符号表，导致`FuncFParamSymbol`插入到了错误的符号表中。

- `FuncDef`的成员`FuncFParams`可能为空，获取`FuncDef`的参数数量时报错

- 当遇到`int f({`的情况是，由于我的语法分析中，在`parseFParam()`时是根据是否是右括号判断的，这样的话就会有问题，改成了根据是否是`INT`来判断

- 在`visitFuncDef()`中，我在得到最后一个`blockItem`后，没有考虑会有`blockItem->decl`的情况，只考虑了`stmt`，导致如果出现

  ```c++
  int f(){
      int a;
  }
  ```

  就会出现错误。
